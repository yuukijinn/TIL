# mockについて

---

## mockとspy

### **SpyとMockの違いに関するまとめ**

### 1. **概念としてのSpyとMockの本来の意味**

- **Spy（スパイ）**: 実際のオブジェクトの振る舞いを追跡（検証）する仕組み。

  Spyは元々、振る舞いをそのまま使ってログを取るのが目的で、振る舞い自体を操作することはない。

- **Mock（モック）**: 振る舞いを完全に制御（モック化）し、呼び出しや引数の検証を行う仕組み。

  Mockは実際の動作を一切使わず、モックされた挙動を使うのが本来の意味。


---

### 2. **フレームワークごとの実装が異なる**

実装によって、SpyとMockの動作や役割がバラバラになることが多い。

- **Mockito（Java）**:
    - **Spy**: 実際のオブジェクトをラップしつつ、一部のメソッドだけモック化できる。
    - **Mock**: 完全にモック化して、すべての振る舞いを制御する。
    - → **MockitoのSpy**は「元の挙動 + 部分モック化」という強力な機能を持っている。
- **Python（unittest.mock）**:
    - **Spy相当（MagicMock + wraps）**: 元の振る舞いを保持しつつ、履歴を追跡する。
    - **Mock**: 完全に振る舞いをシミュレーションする。
    - → **Python**では、SpyとMockは本来の概念に近い。
- **Sinon.js（JavaScript）**:
    - **Spy**: 追跡専用だが、振る舞いを部分的に上書きする機能もある。
    - **Mock**: 振る舞いの制御と呼び出し検証を行う。
    - → **MockとSpy**はかなり近い挙動を持っている。

---

### 3. **Mockitoにおける差別化**

Mockitoでは、SpyとMockを以下の点で差別化している。

- **Spy**:
    - 実際のオブジェクトをラップする。
    - 特定のメソッドだけをモック化できる。
    - 部分的に元の動作を利用したい場合に便利。

    ```
    MyClass spyObj = spy(new MyClass());
    doReturn("Mocked Value").when(spyObj).someMethod();
    ```

- **Mock**:
    - オブジェクト全体をモック化し、すべてのメソッドがモックとして振る舞う。
    - 完全にモック化されたオブジェクトが欲しい場合に使う。

    ```
    MyClass mockObj = mock(MyClass.class);
    when(mockObj.someMethod()).thenReturn("Mocked Value");
    ```


---

### 4. **なぜ統一されないのか？**

- **ユースケースの多様性**: 各フレームワークは異なる用途を想定して設計されているため、SpyとMockの定義が異なる。
- **柔軟性のための曖昧さ**: 特にMockitoのように「部分モック化が可能」という設計があると、SpyとMockの境界が曖昧になりがちだ。
- **歴史的経緯**: SpyやMockの本来の定義があまり厳密でないため、フレームワークごとの実装が自由に解釈されてしまっている。

---

### 5. **結論**

- **Mockitoにおいては、Spyは「特定のメソッドだけモック化できる強化版Mock」という形で差別化されている**。
- **「Spy＝元の挙動をそのまま使うだけ」という概念は、Mockitoでは実装の一部に過ぎない**。
- **本来の意味とは多少ズレがあるものの、MockitoではSpyとMockを明確に使い分けることで、柔軟なテストが実現できている**。
- 「統一しろよ！」という気持ちが湧き出てくるが、各フレームワークの背景や目的を理解して使い分けるしかない。
